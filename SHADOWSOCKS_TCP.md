# Предварительные условия
У вас есть роутер Keenetic и поднят внешний сервер shadowsocks https://shadowsocks.org/. Про shadowsocks лучше почитать отдельно. В двух словах, это супер легкий прокси с обфускацией трафика. Серверная часть принимает обфусцированный трафик от клиентской части и перенаправляет его уже на целевые адреса. Клиентская часть принимает трафик, обфусцирует и отдает серверу. Принимает трафик клиентская часть несколькими способами: может притвориться SOCKS5 прокси, может быть прозрачным прокси и может принимать тунельный трафик от VPN.

# Можно все сделать средствами Keenetic?
В последних версиях KeeneticOS появился SOCKS5 прокси, который можно использовать для выхода в интернет. Казалось бы - идеальный вариант, Keenetic сам заворачивает все в SOCKS5 на клиент Shadowsocks и все настраивается из интерфейса. Вариант выглядел изначально странным, ведь "выход в интернет" в терминах Keenetic, это IP уровень (L3 OSI), а SOCKS5 - сеансовый (L5 OSI), таким образом уже становится очевидно, что ВЕСЬ трафик таким образом завернуть нельзя. OCKS5 клиент в Keenetic построен на базе проекта badvpn https://github.com/ambrop72/badvpn/tree/master/tun2socks, который не развивается с 2015 года. Возможно поэтому к качеству его работы есть вопросы, а главное, он не заворачивает даже UDP трафик, не говоря уже о других протоколах. То есть только TCP. А значит DNS запросы будут ходить мимо него, что вообще в целом означает, что такое подключение не может использоваться для полноценного выхода в интернет. Кроме того, в версии Keenetic OS 3.9.5 есть баг, которыйне прописывает дефолтный маршрут для "выхода в интернет". Исправлен уже в разработческих alpha версиях. Тем не менее, если вам нужен только TCP и все и не пугают возможные проблемы - можно попробовать его использовать, но подробно я это описывать не буду.

# Поехали
1. Установить Entware, лучше во внутреннюю память роутера, но можно и на флешку. Все пакеты в памяти займут не больше 16Мб, такой объем есть на всех роутерах Keenetic.
[Инструкция](https://help.keenetic.com/hc/ru/articles/360021888880-%D0%A3%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0-OPKG-Entware-%D0%BD%D0%B0-%D0%B2%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%BD%D1%83%D1%8E-%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C-%D1%80%D0%BE%D1%83%D1%82%D0%B5%D1%80%D0%B0)

***Update 2024:*** *Спустя год работы роутера в режиме жесткого отключения электропитания пару раз в месяц, внутренняя память роутера умерла. Так что не могу более советовать установку на внутреннюю память. Лучше на внешнюю флешку и не забывать делать бекапы всего диска с Entware. Интересно, что действительно, как и обещали разработчики Keenetic, умер только примонтированный раздел, ОС роутера продолжает работать штатно, что радует.*

   **ВАЖНО!** При маунте storage с папкой Install начинается процесс установки. Он может занять время, надо смотреть логи в "Диагностика" в интерфейсе. После установки будет доступен SSH с параметрами из логов.

   Получили доступ к SSH с Entware, заходим туда.

3. 
   ```bash
   opkg update
   opkg install mc dnsmasq-full ipset iptables shadowsocks-libev-ss-redir shadowsocks-libev-config bind-dig
   ```

   С первого раза может не установится из-за ограниченной памяти и скачивания всего сразу, можно выполнить второй раз.
   
## Настройка shadowsocks клиента. 

Запускать будем в режиме прозрачного прокси (ss-redir) и перенаправлять трафик на уровне iptables.
Создать файл `/opt/etc/shadowsocks.json` с содержимым:
```json
{
 "server":"99.99.99.99",
 "mode":"tcp_only",
 "server_port":443,
 "local_address":"0.0.0.0",
 "local_port":1080,
 "password":"0u8sdufh73",
 "timeout":300,
 "method":"chacha20-ietf-poly1305"
}
```
Ну конечно меняем содержимое под настройки нашего внешнего сервера. Алгоритм `chacha20-ietf-poly1305` лучше не менять, из рекомендованных к использованию он самый быстрый.

Редактируем `/opt/etc/init.d/S22shadowsocks`, нужно убедиться, что запуск и аргументы корректны, должно быть
```bash
PROCS=ss-redir
ARGS="-c /opt/etc/shadowsocks.json"
```

Теперь управление сервисом можно осуществлять через `/etc/init.d/S22shadowsocks start|stop|restart`

**Полезное для диагностики:**
- Запуск shadowsocks в консоли для просмотра вывода: `ss-redir -v -c /opt/etc/shadowsocks.json`
- Проверка открытых портов `netstat -lnp`
- Можно поменять на ss-local и проверить связку клиент-сервер SS, подключившись в SS клиенту на роутере (192.168.0.1:1080) как к SOCKS5 прокси. Можно для этого использовать средства браузера, расширений, таких как FoxyProxy или вообще скачать десктопный клиент Shadowsocks.

## Настройка переадресации iptables
Самая важная часть. Базовые принципы работы iptables [Описаны тут](https://interface31.ru/tech_it/2020/02/osnovy-iptables-dlya-nachinayushhih-chast-1.html). Хотя есть один нюанс, не описанный в этой статье. После цепочки OUTPUT (локальный трафик) будет произведен re-routing, если были изменения в метках MARK пакета. Помимо этого основные знания, которые нам понадобятся:
- В цепочку PREROUTING попадают только транзитные пакеты
- В цепочку OUTPUT попадают только локально инициированные пакеты
- В таблице nat можно изменить адрес назначения
- В таблице mangle можно "помечать" (MARK) пакеты для дальнейшего роутинга как нам нужно через ip rule и ip route

Создаем файл `/opt/root/iptables_nat.sh`. После создания конечно даем права на исполнение, про это не буду далее напоминать.
```bash
#!/bin/sh

[ -n "$(iptables-save | grep SS_TCP)" ] && exit 0

# Disable ndnproxy this way, coz dns-override sometimes switches back after reboot.
iptables -F _NDM_HOTSPOT_DNSREDIR -t nat

ipset list unblock > /dev/null 2>&1 && ipset flush unblock # flush if set exists
ipset create unblock hash:net -exist

# Create new chain
iptables -t nat -N SS_TCP

# Anything else should be redirected to shadowsocks's local port
iptables -t nat -A SS_TCP -p tcp -m mark --mark 0xffffd01 -m set --match-set unblock dst -j REDIRECT --to-ports 1080

# Apply the rules to transit packets
iptables -t nat -A PREROUTING -p tcp -j SS_TCP
```

Давайте разберемся. Скрипт будет запускаться многократно из-за нюансов работы Keenetic, он очень часто сбрасывает iptables таблицы к исходному состоянию по своим внутренним причинам. Поэтому проверяем, существует ли наша цепочка в правилах. Меняем таблицу nat. Отключаем цепочку, которая перенаправляет DNS запросы на внутренний DNS сервер Keenetic. В теории должно быть достаточно команд
```
opkg dns-override
system configuration save
system reboot
```
но у меня такая конфигурация срабатывала через раз после перезагрузки роутера. А после обновления прошивки вообще перестала работать. Поэтому был найден дополнительный способ отключения. Тем не менее, сделать эти команды все-же в любом случае надо, иначе dnsmasq не сможет поднятся на стандартном 53 порту. Далее сначала очищаем, потом создаем ipset, в который в последствии будет писать dnsmasq. Очистка периодически нужна, потому что после длительного использования некоторые IP адреса могут начать использоваться другими сайтами, которые мы не хотим вести в SS. Создаем цепочку SS_TCP, в которую уходят tcp пакеты на этапе PREROUTING. **Важно!** в PREROUTING попадают только транзитные пакеты. Сгенерированные на роутере пакеты попадут в OUTPUT. Перенаправление происходит по нескольким условиям
1. `-m mark --mark 0xffffd01`
   Это метка, которая ставится роутером в зависимости от нахождения хоста-инициатора пакета в политике доступа в интернет ("приоритеты подключений" в интерфейсе Keenetic). Таким образом, мы можем управлять для каких клиентов включить такое перенаправление. Чтобы узнать метку, сделайте `iptables-save | grep MARK` и посмотрите каким IP адресам какие метки присваиваются, по ним можно будет понять у какой группы какая метка.
2. `-m set --match-set unblock dst`
   IP адрес назначения соответствует списку IP адресов "unblock". Этот ipset будет постоянно обновляться нашим DNS сервером на лету.

Теперь этот скрипт можно запустить вручную и проверить работу. Если что-то не так - можно перезагрузить роутер. **В автозагрузку добавлять только после того как все протестировано!** Для добавления в автозагрузку (формально это не совсем автозагрузка, скрипт вызывается роутером в момент очистки и перезагрузки определенной таблицы iptables, таблица nat и mangle перезагружается роутером многократно) создадим файл `/opt/etc/ndm/netfilter.d/iptables_nat_reload.sh` с содержимым:
```bash
#!/bin/sh

[ "$type" == "ip6tables" ] && exit 0   # check the protocol type in backward-compatible way
[ "$table" == "nat" ] || exit 0   # check the table name

logger "iptables $table reloaded: load /opt/root/iptables_nat.sh"

/opt/root/iptables_nat.sh
```

**Полезное для диагностики:**
- `iptables-save | grep SS_TCP` - покажет все добавленные вами правила

## Настройка DNS сервера dnsmasq
DNS сервер выполняет 2 задачи:
1. На основе домена заполняет ipset IP адресами, по которым будет фильтроваться трафик в iptables
2. Вышестоящий upstream DNS сервер будет выбираться также в зависимости от домена. Таким образом, для перечисленных адресов будут использоваться одни DNS серверы, для всех остальных - стандартный. Это даст возможность не потерять резолв локальных сетевых адресов.

Добавим в конец файла `/opt/etc/dnsmasq.conf`
```
conf-file=/opt/etc/unblock.dnsmasq
```
Все настройки будем проводить в файле `/opt/etc/unblock.dnsmasq`, нужно его создать, например, с таким содержимым:
```
# Заполнить, если были локальные доменные имена, добавленные через ip host в Keenetic
address=/example.lan/192.168.1.18

# Команда для заполнения ipset
ipset=/site.com/unblock
ipset=/sitecdn.com/unblock

# Команда для указания конкретного DNS сервера для резолва домена, никакие другие использоваться не будут.
server=/site.com/1.1.1.1
server=/site.com/8.8.8.8
server=/sitecdn.com/1.1.1.1
server=/sitecdn.com/8.8.8.8
```
Если на резолв локальных адресов пофиг, то можно просто глобавльно оставить постоянные upsream dns сервера `server=1.1.1.1` и не писать их для каждого домена отдельно.

Заполнить по аналогии все нужные домены. Учтите, что `ipset=/example.com/` также включает в себя все домены 2,3 и тд уровней, то есть `my.example.com` тоже будет включен.

Теперь нужно подключить hosts (для корректного резолва localhost) и resolv.conf (для поддягивания правильных upstream dns серверов для всех доменов, которые не были перечислены выше). Если на резолв локальных адресов пофиг, то resolv.conf можно не добавлять. Выполним команды:
```bash
ln -s /var/hosts /opt/etc/hosts
ln -s /var/resolv.conf /opt/etc/resolv.conf
/opt/etc/init.d/S56dnsmasq restart
```

Если рестарт dnsmasq не работает, скорее всего из-за того, что порт занят стандартным DNS сервером. В этом случае выполняем:
```
opkg dns-override
system configuration save
system reboot
```

**Полезное для диагностики:**
- Не забываем про кеш DNS. Сброс кеша на Windows: `ipconfig /flushdns`. Сам dnsmasq тоже кеширует результаты, по умолчанию на величину TTL, что логично. Но можно переопределить опцией `min-cache-ttl` в конфиге.
- `nslookup example.com 192.168.0.1`
- `dig @localhost example.com`
- Смотрим логи в Диагностика->Системный журнал
- Проверяем работу, чтобы убедиться что пакеты перенаправляются можно выключить временно shadowsocks: `/etc/init.d/S22shadowsocks stop`

# Дополнительные материалы
Многое описано на основе статей
https://habr.com/ru/post/663862/
https://habr.com/ru/post/428992/
Но в них много ненужного и многое не работает. Тем не менее, спасибо авторам за идею, ключевая конечно это dnsmasq.
